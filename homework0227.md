## 변수의 생명 주기

## 지역 변수의 생명 주기
변수에게는 생명주기(Life cycle)이 있다. 
생명 주기가 없다면 무한반복될 것이기 때문이다...

변수는 선언된 위치에서 생성되고 소멸한다. 
전역 변수의 생명주기는 애플리케이션의 시작과 종료와 같고
함수 내부에서 선언된 지역변수의 생명주기는 함수의 호출과 종료와 같다.


자바스크립트 엔진은 변수 선언이 어디에서 되었든 
런타임 이전에 실행한다.

함수 몸체 안의 변수 선언도 마찬가지다. 
이후 몸체 안의 남은 문들은 순차적으로 실행이 되고 
변수 할당문이 실행되면 변수에 값이 할당된다.

`함수의 생명 주기 = 지역 변수의 생명 주기`

전역변수의 호이스팅은 전역 전체에서 일어난다. 

지역 변수의 호이스팅은 자신의 지역 스코프 안에서 일어난다.
지역 변수는 자신을 품은 함수 안에서 유효하다.


## 전역 변수의 생명 주기
전역 변수에서 말하는 전역이라는 개념은 window이다.
즉 전역 변수는 window라는 브라우저의 프로퍼티라 볼 수 있다.
전역 변수는 웹페이지를 실행과 동시에 작동하고 웹페이지의 종료와 함께 종료된다. 
시작을 하는 데 있어 특별한 진입점(entry point)이 없다.

var 키워드로 선언한 전역 변수 역시 웹페이지가 종료되어야 함께 종료된다.


## 전역 변수의 문제점

# 암묵적 결합
전역변수는 어디서든 참조가 가능하다. 
이것은 모든 코드가 전역 변수에 영향을 미칠 수 있다는 뜻이다.
이를 두고 암묵적 결합(implicit coupling)을 허용한다고 한다.
이렇게 코드가 암묵적 결합이 되면 
가독성이 나빠지고 의도치 않는 변경으로 인해 뜻하지 않은 결과를 떠안을 수 있다.

# 긴 생명 주기
앞서 말한 바와 같이 전역 변수는 생명 주기가 길다. 
생명 주기가 길면 사용하는 메모리도 상대적으로 길어지고 많아진다.

또 같은 이름의 변수 선언이 이루어질 확률도 덩달아 높아진다.

# 스코프 체인 상에서 종점에 존재
전역 변수는 스코프 체인에서 종점에 위치하기에 
검색 속도가 느려질 수밖에 없다. 
요즘은 기술발달로 검색 속도의 차이를 
크게 느끼지 않을지 모르지만 분명히 속도의 차이는 있다.

# 네임 스페이스 오염
가장 치명적인 문제점이라 할 수 있어 보이는... 
자바스크립트에서 가장 큰 문제점이라 지적되는 것은,
파일이 분리돼 있어도 window 전역의 전역객체를 모든 파일이 공유하기에, 
다른 파일 내에서도 동일한 이름의 변수나 함수를 선언하기 매우 조심스러워진다. 
이유는 a.js에서 abc 라는 식별자를 사용하면 
b.js의 abc라는 변수 혹은 함수에 영향을 미칠 수 있기 때문이다.


## 전역 변수 사용 억제 방법

# 즉시 실행 함수
즉시 실행 함수는 함수를 정의하자마자 1회용으로 호출된다. 
모든 코드를 즉시 실행 함수로 감싸면 
안에 들어간 변수들은 즉시 실행 함수의 지역 변수가 된다. 

생명 주기가 짧기에 코드가 변경될 틈이 없어져서 안정성을 높여준다.

이 방법을 사용하면 전역 변수를 생성하지 않기에 라이브러리 등에서 자주 사용된다.

# 네임 스페이스 객체
전역에 네임 스페이스(Namespace) 역할을 할 객체를 생성하고 
전역 변수처럼 사용하고 싶은 변수를 프로퍼티로 추가한다.

var MYAPP = {};  //  전역 네임 스페이스 객체

MYAPP.person = {
  name: 'Lee',
  address: 'Seoul'
};

console.log(MYAPP.person.name);  //  Lee

네임 스페이스를 분리해 식별자끼리 영향을 미치는 일은 피할 수 있겠지만 
어차피 전역 변수에 할당되기에 유용성은??? 미지수.

# 모듈 패턴
모듈 패턴은 클래스를 모방하여(아직 안 배움) 
관련이 있는 변수와 함수를 모아 즉시 실행 함수로 감싸 하나의 모듈을 만든다.

자바스크립트의 강력한 기능인 클로저를 기반으로 동작한다. 
모듈 패턴의 특징은 전역 변수의 억제는 물론 캡슐화까지 구현할 수 있다는 점이다.

캡슐화는 말에서 느껴지는 뉘앙스처럼, 
정보 은닉(information hiding)리라고도 한다.

자바스크립트에서 작동하는 모듈 패턴은 
전역 네임 스페이스의 오염을 막고 (한정적이지만) 캡슐화를 구현할 수 있다.

외부로 노출하고 싶지 않은 변수나 함수를 반환하는 객체에 추가하지 않으면 
외부에서 접근할 수 없는 private member가 된다.

var Counter = (function () {
  // private 변수
  var num = 0;
  // 외부로 공개할 데이터나 메소드를 프로퍼티로 추가한 객체를 반환한다.
  return {
    increase() {
      return ++num;
    },
    decrease() {
      return --num;
    }
  }
)()};

// private 변수는 외부로 노출되지 않는다.
console.log(Counter.num);  //  undefined

console.log(Counter.increase());  //  1
console.log(Counter.increase());  //  2
console.log(Counter.decrease());  //  1
console.log(Counter.decrease());  //  0

# ES6 모듈
모던 브라우저에서는 ES6모듈을 사용할 수 있다.
Chrome61, FF 60, SF 10.1, Edge 16 이상..

예시)
<script type="module" src="lib.mjs"></script>
<script type="module" src="app.mjs"></script>

다만 IE를 포함한 구형 브라우저에서 작동하지 않고 
ES6모듈 기능을 사용한다 해도 트랜스 파일링이나 번들링이 필요하기에 
Webpack 등의 모듈 번들러를 사용하는 것이 일반적이다.