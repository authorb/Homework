## 함수란?
함수는 일련의 과정을 문들로 구현하고 코드블록을 감싸는 하나의 실행단위.

함수 용어는 앞서 배운 용어와 조금 다른 듯.
함수 몸체로 들어올 때 변수를 매개변수(parameter), 입력을 인수(argument), 출력을 반환값(return value)이라 한다.

함수는 정의만으로 실행되지 않고 함수 호출(Function call/invoke)을 통해 실행시킨다.


## 함수 사용 이유
1. 재사용 할 수 있다. 
   반복작업해야할 때 함수 하나 만들어서 호출만으로 같은 작업을 반복할 수 있다.

2. 만든 프로그램을 이해하기 쉽다.
   식별자만 잘 붙이면 코드 내용을 쉽게 파악할 수 있다.

3. 수정 용이하다. 
   함수로 정리해두면 문제가 생겼을 때 해당 함수만 수정하면 된다.


## 함수 리터럴
함수 리터럴의 구성 : function 키워드, 함수 이름, 매개 변수 목록, 함수 몸체.

함수 이름 : 식별자. 몸체 내에서만 참조할 수 있는 식별자. 익명함수, 무명함수 가능. 끝에 새미콜론 붙여야 함.

매개변수 목록 : 0개 이상 매개변수를 소괄호로 감싸고 쉼표로 구분. 
함수 호출문의 인수는 순서대로 할당. 매개변수는 몸체 내에서 변수와 동일하게 취급.

함수 몸체 : 함수가 호출됐을 때 일괄적으로 실행될 문들을 하나의 실행 단위로 정의한 코드블록 {...}.

함수 리터럴도 값을 생성하며 이 값은 객체다.

**함수 객체와 일반 객체의 다른점**
일반 객체는 호출할 수 없다.

함수는 호출 가능. 함수 객체의 고유한 프로퍼티 갖는다.


## 함수 정의
1. 함수 선언문
2. 함수 표현식
3. 생성자 함수
4. 화살표 함수


## 변수 선언과 함수 정의
변수는 선언됐다고 하지만 함수는 정의됐다고 한다. 

선언은 식별자만 생성, 값은 아직 할당되지 않은 상태.

정의는 식별자가 생성되었고 값도 할당된 상태.

**함수 정의는 식별자와 값이 모두 할당된 상태를 의미한다.**


## 함수 선언문
함수 선언문의 형태는 리터럴과 동일하나 
함수 선언문은 선언문이기에 함수 이름을 생략할 수 없다. 

함수 선언문은 표현식이 아닌 문이기에 
변수에 할당이 되지 않는다.

함수 선언문은 이름을 반드시 붙여줘야 한다는 점에서 
함수 리터럴과 형태가 같다. 

자바스크립트 엔진은 함수 이름이 있는 함수 리터럴을 단독으로 사용하면 
함수 선언문으로 해석한다. 
하지만 함수를 정의하는 내부 동작에 차이가 있다.

// 자바스크립트 엔진은 이름 있는 함수 리터럴을 
단독으로 사용하면 함수 선언문으로 해석한다.
// 함수 선언문은 함수 이름을 생략할 수 없다.
// 함수 선언문으로 생성된 함수 리터럴(foo)는 함수 외부에서 호출 가능
function foo() { consloe.log('foo');}
foo();  //  foo

foo라는 식별자는 원래 함수 몸체 내부에서만 유효할 수 있고 외부에서는 호출할 수 없는데, 
자바스크립트 엔진이 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 생성된 함수 객체를 할당했다.

자바스크립트 엔진은 (개발자가 지정한)함수 이름을 호출한 것이 아니라 
(자바스크립트 엔진 자신이 암묵적으로 생성한)식별자로 함수를 호출한다. 

여기서 헷갈리는 것은 (개발자가 지정한)함수 이름과 
(자바스크립트 엔진 자신이 생성한)식별자 이름이 일치하기 때문에 
함수 이름으로 호출된 것처럼 보이기 때문이다.

**자바스크립트 엔진은 함수 선언문을 함수 표현식으로 변환하여 함수 객체를 생성한다고 생각할 수 있다.** 
단 함수 선언문과 함수 표현식은 동일하게 동작하지 않는다.


## 함수 표현식
자바스크립트에서 함수는 객체 타입의 값이다. 
자바스크립트의 함수는 변수에 할당할 수 있고 
프로퍼티 값이 될 수 있고 
배열의 요소도 될 수 있다. 
이처럼 값의 성질을 갖는 객체를 일급 객체(first-class object)라 한다. 
일급객체인 함수는 값처럼 자유롭게 사용할 수 있다.

var add = function (x, y) {
  return x + y;
};
console.log(add(2, 5));  //  7


// 함수 리터럴을 피연산자로 사용하면 함수 선언문이 아니라 함수 리터럴 표현식으로 해석한다.
// 함수 리터럴은 함수 이름을 생략할 수 있다.
// 함수 리터럴 표현식으로 생성된 bar는 호출 불가능
(function bar() { console.log('bar); });
bar();  //  ReferenceError: bar is not defined.

함수 리터럴의 함수 이름은 생략 가능(익명함수)하며 
함수 표현식의 함수 리터럴은 이름을 생략하는 것이 일반적이다. 
함수 이름(bar)은 함수 몸체 내부에서만 유효하다. 

//기명 함수 표현식
var add = function foo (x, y) {
  return x + y;
};

// 함수 객체를 가리키는 식별자로 호출
console.log(add(2, 5));  //  7

// 함수 이름으로 호출하면 ReferenceError가 발생한다.
// 함수 이름은 함수 몸체 내부에서만 유효한 식별자다.
console.log(foo(2, 5));  //  ReferenceError: foo is not defined.


## 함수 생성 시점과 함수 호이스팅

함수 선언문으로 정의한 함수는 함수 선언문 이전에 호출할 수 있다. 

함수 표현식으로 정의한 함수는 함수 표현식 이전에 호출할 수 없다.

함수 선언문으로 정의한 함수와 
함수 표현식으로 정의한 함수의 생성 시점이 다르다.

함수 호이스팅이 일어난다.
함수 선언문이 뒤에 쓰여져도 맨 앞에 쓰여진 것처럼 동작한다.

변수 호이스팅과 다른 점은, 
함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화된다는 점이다. 

함수 표현식은 변수 호이스팅처럼, 
함수 표현식 이전에 함수를 참조하거나 함수를 호출하면 undefined가 호출된다.

함수표현식은 반드시 함수 표현식 이후에 참조하거나 호출해야 한다.


## Function 생성자 함수

# 생성자 함수(Constructor Function)
생성자 함수는 객체를 생성하는 함수를 말한다. 객체 생성하는 방식은 리터럴 말고도 다양하다. 

Function 생성자 함수 예시
var add = new  Function('x', 'y', 'return x + y');
console.log(add(2, 5));  //  7

Function 생성자 함수로 함수를 생성하는 방식은 일반적이지 않고 바람하지도 않다.
 또 이렇게 생성된 함수는 클로저를 생성하지 않고 
 함수 선언문이나 함수 표현식으로 생성한 함수와 다르게 작동한다.


## 화살표 함수(Arrow funtion)
=> 를 사용해 간략하게 함수 선언할 수 있다.

화살표 함수는 항상 익명 함수로 정의된다.

// 화살표 함수
const add = (x, y) => x + y;
console.log(add(2, 5));  //  7

화살표 함수는 생성자 함수로 사용할 수 없고
기존 함수와 this 바인딩 방식이 다르고
prototype 프로퍼티가 없으며
arguments 객체를 생성하지 않는다.


## 함수 호출
함수를 호출하면 현재 실행 흐름을 중단하고 함수 컨트롤을 넘긴다. 
매개변수의 인수 순서대로 할당되고 함수 몸체의 문들이 실행되기 시작한다.


## 매개변수와 인수

# 함수 실행 순서
인수가 매개변수에 전달되고 
매개변수가 함수 몸체로 들어가서 
식을 실행한 다음 나온 값을 
다시 함수 몸체 바깥으로 반환한다(뱉어낸다, 토해낸다).

매개변수는 함수 몸체 내부에서 변수와 동일하게 취급된다. 

매개변수는 함수 몸체 내부에서만 참조할 수 있고 
함수 몸체 외부에서는 참조할 수 없다. 


## 인수 확인

function add (x, y) {
  return x + y;
}
console.log(add(2));  //  NaN
console.log(add('a', 'b'));  //  'ab'

자바스크립트 함수는 매개변수와 인수의 개수가 일치하는지 확인하지 않는다.
자바스크립트 함수는 매개변수의 타입을 사전에 지정할 수 없다.

따라서 자바스크립트의 경우 함수를 정의할 때 적절한 인수가 전달되었느지 확인이 필요하다.

방법 1. TypeScript에서 자바스크립트의 상위 확장을 도입해 컴파일(compile) 시점에 부적절한 호출을 방지한다.

방법 2. 단축 평가를 사용해 매개변수에 기본값을 할당해본다.


## 매개 변수 최대 개수 : 3개까지는 권장
매개 변수는 가능한한 적게 쓰는 게 좋고 최대 3개를 넘지 않는 것을 권장한다. 만약 그보다 더 많이 필요하다면 하나의 매개 변수를 선언하고 객체를 인수로 전달받는 것이 유리하다. 

단, 함수 외부에서 함수 내부로 전달한 객체를 함수 내부에서 변경하면 
함수 외부의 객체가 변경되는 부수효과(side-effect)가 발생한다..


## 반환문
return 키워드 사용.

반환문 역할 
역할 1. 함수 실행 중단하고 함수 몸체 빠져 나간다.
역할 2. return 키워드 뒤에 지정한 값을 반환한다. 

만약 반환값을 지정하지 않으면 undefined가 반환된다.
return 키워드와 지정한 값은 줄바꿈하지 않는다.


## 참조에 의한 전달과 외부 상태의 변경
함수의 매개변수에 값을 전달하는 방식으로 
값에 의한 호출(Call by value), 
참조에 의한 호출(Call by reference)이 있다. 
동작 방식은 동일하다.

원시 타입 인수는 값이 변경되지 않고 복사되어 매개변수에 전달되고 그 값을 재할당해도 원본이 훼손되지 않는다. 값의 부수효과 없음

객체 타입 인수는 참조값이 매개 변수에 전달되기 때문에 객체를 변경할 경우 원본에 고스란히 반영되어 원본이 훼손된다. 값의 부수효과 발생.

이렇게 될 때 코드가 복잡해지고 원인 찾기가 힘들어져서 유지보수가 어려워진다.

자바스크립트에서 객체는 변경 가능한 값이기에 이와 같은 문제가 발생하기에 Observer패턴 등을 통해 객체 참조를 공유하는 모든 이들에게 객체 변경 사실을 알리고 추가 대응해야 한다. 

이에 대한 문제 해결 방법으로, 불변 객체를 만들어 사용하는 것이 있다. 객체 복사본을 새롭게 만들어서 객체를 마치 원시값처럼 변경불가능한 값으로 동작하게 하는 것이다. 참조가 아닌 객체의 방어적 복사를 통해 원본 객체를 '깊은 복사'를 하고 새로운 객체를 생성해 재할당, 교체를 하게 되면 외부상태 변화로 인한 부수효과를 없앨 수 있다.

외부상태를 변경하지 않고 의존하지 않는 함수를 순수함수라 한다. 순수 함수를 사용해서 프로그램의 안정성을 높이는 것을 함수형 프로그래밍이라 한다.


## 다양한 함수의 형태
## 즉시 실행 함수
함수 정의와 동시에 호출되는 함수를 즉시 실행 함수(IIFE, Immediately Invoked Function Expression)라 한다. 

즉시 실행 함수는 단 한 번만 호출된다.

익명 함수를 사용하는 것이 일반적이다. 
(기명 함수를 사용하면 그룹 연산자 내에서 함수 선언문 아닌 함수 리터럴로 평가돼, 함수 이름을 함수 몸체에서만 참조할수 있어서 즉시 실행 함수를 다시 호출할 수 없다.)

즉시 실행 함수는 반드시 그룹 연산자로 감싸주어야 한다. 그렇지 않으면 함수 선언문의 형식에 맞지 않다는 에러가 뜬다. 함수 선언문 뒤의 그룹 연산자에 피연산자가 없기 때문이다.
(기명 함수를 정의해도 에러가 뜨는데 자바스크립트 엔진이 세미콜론 자동 삽입 기능 때문에 함수 코드블록 중괄호 뒤에 세미콜론을 추가하기 때문이다)

그룹 연산자의 피연산자는 값으로 평가 되기에 무명함수 또는 기명함수를 그룹 연산자로 감싸, 함수 객터럴로 평가 되고 함수 객체가 된다.

함수를 평가해서 함수 객체를 생성하면 그룹연산자 이외의 연산자도 사용할 수 있다.

console.log(typeof (function f(){}));  //  function

그룹 연산자로 함수를 묶으면 함수를 먼저 평가해서 함수 객체를 생성할 수 있고 이후 그룹 연산자 이의 연산자도 실행할 수 있기 때문이다. 

즉시 실행 함수는 일반함수처럼 값을 반환할 수 있고 인수를 전달할 수도 있다.

즉시 실행 함수 내에 코드를 모아두면 변수나 함수 이름의 충돌을 방지할 수 있다.


## 재귀 함수(recursive function)
재귀 호출 : 함수가 자기 자신을 호출하는 것.
재귀 함수 : 재귀 호출을 수행하는 함수.

재귀 함수를 자신을 무한 호출하기에 탈출조건을 만들어야 한다. (무한 호출되면 stack overflow 에러 발생)

함수 표현식으로 정의한 함수 내부에서 재귀 호출은 식별자로 해야 한다.

팩토리얼은 재귀 호출로 구현할 수 있다.

이때 반복문인 for 문이나 while문을 사용할 수 있다.

재귀함수는 직관적으로 이해하기 쉬울 때만 한정적으로 사용하는 것이 바람직하다.

// 함수 표현식 if문 사용
var factorial = function foo(n) {
  // 탈출조건 : n이 1 이하일 때 재귀호출을 멈춘다.
  if (n <= 1) return 1;
  // 함수를 가리키는 식별자로 자기 자신을 재귀 호출한다.
  return n * factorial(n - 1);
};
console.log(factorial(5));  //  5! = 5 * 4 * 3 * 2 * 1 = 120
}

function factorial(n) {
  if (n <= 1) return 1;

  var res = n;
  while (--n) res *= n;
  return res; 
}
console.log(factorial(5));  //  5! = 5 * 4 * 3 * 2 * 1 = 120


## 중첩 함수
함수 내부에 정의된 함수를 중첩 함수(nested function)라 한다. 중첩함수를 포함하는 함수를 외부함수(outer function)라 부른다.

중첩함수는 자신을 포함한 외부 함수를 돕는 헬퍼 함수(helper function) 역할을 한다.

ES6부터 if문, for문 등의 코드 블록 내에서도 정의할 수 있으나 호이스팅으로 혼란 발생할 수 있으니 함수 선언문을 통해 함수를 정의하지는 말자.

스코프, 클로저와 깊은 관련이 있다.


## 콜백 함수

모르겠음...

// n만큼 어떤 일을 반복한다.
function repeat1(n) {
  // i를 출력한다.
  for (var i = 0; i < n; i++) console.log(i);
}
repeat1(5);  //  0 1 2 3 4

// n만큼 어떤 일을 반복한다.
function repeat2 (n) {
  for (var i = 0; i < n; i++) {
    // i가 홀수일 때만 출력한다.
    if (i % 2) console.log(i);
  }
}
repeat2(5);  //  1 3

위의 두 함수는 반복한다는 공통점을 지니고 있지만 각자 수행된 결과가 다르다. 만약 위와 같은 결과를 내야 한다면 함수를 매번 만들어야 하는데, 이보다는 공통된 것은 적어두고 바뀌는 부분만 변경하면 될 것이다. 

// 콜백함수 예시
//외부에서 전달받은 f를 n번 만큼 반복 호출한다.
function repeat(n, f) {
  for (var i= 0; i < n; i++) {
    //i를 전달하면서 f를 호출한다.
    f(i);
  }
}

var logAll = function (i) {
  console.log(i);
};

// 반복 호출할 함수를 인수로 전달한다.
repeat(5, logAll);  //  0 1 2 3 4 // 여기서 5는 n이다.

var logOdds = function (i) {
  if (i % 2) console.log(i);
};

// 반복 호출할 함수를 인수로 전달한다.
repeat(5, logOdds); // 1 3

repeat 함수는 경우에 따라 변경되는 일을 함수 f로 추상화했고 이를 외부에서 전달받는다. 자바스크립트 함수는 함수의 매개변수를 통해 함수를 전달할 수 있다. repeat 함수는 내부 로직에 강력히 의존하지 않고 외부에서 로직의 일부분을 함수로 전달받아 수행하므로 유연한 구조를 갖게 되었다.

함수 매개변수를 통해 전달되는 함수를 콜백 함수(Callback function)라 한다. 

**콜백 함수를 매개 변수를 통해 전달받은 함수를 고차함수(Higher-Order Function, HOF)라 한다.** 
매개변수를 통해 함수를 전달받거나 반환값으로 함수를 반환하는 함수를 함수형 프로그래밍 패러다임에서 고차함수라 한다.

콜백 함수는 고차 함수에 전달되어 헬퍼 함수 역할을 한다. 
콜백함수는 함수 외부에서 고차 함수 내부로 주입 가능해서 자유롭게 교체 가능하다. 

이런 유연함, 자유로움 때문에 고차함수는 콜백함수를 자신의 일부분으로 합성한다.

고차 함수는 매개변수를 통해 전달받은 콜백 함수의 호출 시점을 결정하여 호출한다. 

고차 함수에 콜백 함수를 전달할 때 콜백 함수를 호출하지 않고 함수 자체를 전달해야 한다. 

콜백 함수가 고차함수 내부에만 호출된다면 콜백 함수를 익명함수 리터럴로 정의하면서 곧바로 고차 함수에 전달하는 것이 일반적이다. 

// 익명함수 리터럴을 콜백 함수로 매개변수에 전달한다.
// 익명함수 리터럴은 repeat 함수를 호출할 때마다 평가되어 함수 객체를 생성한다.
repeat (5, function (i) {
  if (i % 2) console.log(i);
});  //  1 3

콜백함수로 전달된 함수리터럴은 고차 함수로 호출될 때마다 평가되어 함수 객체를 생성한다. 콜백 함수를 다른 곳에서도 호출할 필요가 있거나 콜백 함수를 전달받는 함수가 자주 호출된다면 함수 외부에서 콜백 함수를 정의한 후 함수 참조를 고차 함수에 전달하는 편이 효율적이다.


var logOdds = function (i) {
  if (i % 2) console.log(i);
};

// 반복 호출할 함수를 인수로 전달한다.
repeat(5, logOdds); // 1 3

위 예제의 logOdd 함수는 단 한번만 생성된다. 

콜백함수를 익명함수 리터럴로 정의하면서 곧바로 고차함수에 전달하면 고차함수가 호출될 때마다 콜백함수가 생성된다.


## 순수함수(Pure function)와 비순수함수(Impure function)
함수형 프로그래밍에서 부수효과 없는 함수를 순수함수,
부수 효과 있는 함수를 비순수 함수라 한다.

순수 함수는 오직 매개변수를 통해 함수 내부로 전달된 인수에게만 의존해서 반환값을 만든다.

순수 함수는 함수의 외부 상태를 변경하지 않는다.

var count = 0; // 현재 카운트를 나타내는 상태

// 순수함수.
// 순수함수는 동일한 인수가 전달되면 동일한 값을 반환한다.
function increase(n) {
  return ++n;
}

// 순수 함수가 바환한 결과값을 변수에 재할당해서 상태를 변경
count = increase(count);
console.log(count);  //  1

count = increase(count);
console.log(count);  //  2


비순수함수는 외부 상태를 변경하는 부수 효과가 있다.

var count = 0; // 현재 카운트를 나타내는 상태 : increase 함수에 의해 변화한다.

// 함수의 외부 상태에 의존하여 외부 상태에 따라 반환값이 달라지는 비순수함수.
// 비순순함수는 부수효과를 지닌다.
function increase () {
  return ++count;  //  외부 상태를 변경한다.
}

// 비순수함수는 외부상태(count)를 변경하므로 상태 변화를 추적하기 어려워진다. 
increase();
console.log(count);  //  1

increase();
console.log(count);  //  2

함수 내부에서 외부를 직접 참조하면 반환값이 변할 수 있고 외부 상태도 변경될 수 있다.

직접 참조하지 않아도 매개변수를 통해 객체를 전달받으면 비순수함수가 된다.

**순수함수를 사용하는 것이 좋다.**

즉 함수형 프로그래밍은 
변수 사용 억제,
순수함수와 보조함수 조합을 통해 로직 내 조건문, 반복문을 제거,
복잡성을 해결
하는 프로그래밍 패러다임이다.


## 스코프란?
자바스크립트의 스코프(Scope)는 다른 언어와 구별된다.

var, let, const 키워드로 선언한 변수마다 스코프가 다르게 동작한다.

매개변수의 스코프는 함수 몸체 내부로 한정되어 있다.

모든 식별자(변수 이름, 함수 이름, 클래스 이름 등)는 자신이 선언된 위치에 의해 다른 코드가 식별자 자신을 참조할 수 있는 유효범위가 결정된다. 

스코프는 식별자가 유효한 범위를 말한다.

스코프(유효범위) 내에서의 식별자는 고유해야 하지만, 다른 스코프(유효범위) 내에서는 같은 이름의 식별자가 있어도 사용하는 데 지장이 없다.

var 키워드로 선언된 변수는 변수값이 재할당될 수 있는 부작용이 있을 수 있으니, var 키워드 사용 자체를 주의하자.

이에 비해 let이나 const 키워드는 같은 스코프 내에서 중복 선언을 허용하지 않는다.


## 스코프의 종류
전역 변수. 전역 스코프. 코드의 가장 바깥.
지역 변수. 지역 스코프. 함수 몸체 내부.

# 전역과 전역 스코프
전역이란 가장 바깥 영역을 말한다. 전역에 변수를 선언하면 전역 스코프를 갖는 전역 변수가 되고 전역 변수는 어디서든 참조 가능하다. 즉, 함수 내부에서도 참조할 수 있다.

# 지역과 지역 스코프
지역이란 함수 몸체 내부를 말한다. 지역에 변수를 선언하면 지역 스코프를 갖는 지역 변수가 된다. 지역 변수는 자신의 지역 스코프와 하위 지역 스코프에서만 유효하다.


## 스코프 체인 
스코프는 함수 중첩에 의해 계층적인 구조를 갖는다. 이 구조에서 상위 스코프는 전역 스코프이다. 가장 깊숙한 곳에 있는 함수가 가장 하위 스코프라 할 수 있다.

이렇게 스코프가 계층으로 연결된 것을 스코프 체인이라 부른다.

변수를 참조할 때 자바스크립트 엔진은 스코프 체인을 통해 변수를 참조하는 코드의 스코프를 시작해 상위 스코프 방향으로 이동하면서 선언된 변수를 검색한다. 

스코프 체인을 통해서 하위 스코프는 상위 스코프를 참조할 수 있다.


## 스코프 체인에 의한 변수 검색
자바스크립트 엔진은 스코프 체인을 따라 상위 스코프로 이동하면서 선언된 변수를 검색 및 적용한다.

상위 스코프에서 유효한 변수는 하위 스코프에서 자유롭게 참조할 수 있다.

하위 스코프에서 유효한 변수는 상위 스코프에서 참조할 수 없다.


## 스코프 체인에 의한 함수 검색
함수 선언문이 정의되면 자바스크립트 엔진은 다른 코드를 실행하기에 앞서 이전에 함수 객체를 먼저 생성한다.

자바스크립트 엔진은 함수 이름과 동일한 이름의 변수를 암묵적으로 선언하고 생성된 함수 객체를 할당한다.

함수도 변수에 할당되기에 스코프를 갖는다. 

함수는 변수에 함수 객체가 할당된 것 외에 일반 변수와 다르지 않다. 

이를 두고 스코프를 식별자를 검색하는 규칙이라고 표현한다.

## 함수 레벨 스코프
블록 레벨 스코프(Block level scope)는 함수 몸체 뿐만 아니라 모든 코드블록이 지역 스코프를 만드는 것을 말한다. 

var키워드로 선언된 변수는 함수 코드 블록만 지역 스코프로 인정한다. 이를 함수 레벨 스코프라고 한다.

var 키워드로 변수를 블록 밖에서 선언하면 안의 똑같은 이름을 지닌 변수의 값이 의도치 않게 재할당될 수 있다.

이에 대응하기 위해 ES6에서 let, const 키워드가 도입됐고 이 두 키워드는 블록 레벨 스코프를 지원한다.


## 렉시컬 스코프
동적 스코프(Dynamic scope) : 함수가 호출되는 시점에 동적으로 스코프를 결정하는 것.

렉시컬 스코프(Lexical scope) : (또는 정적 스코프 Static scope) 상위 스코프가 동적으로 변하지 않고 함수의 정의가 평가되는 시점에 상위 스코프가 정적으로 결정되는 것.

자바스크립트는 렉시컬 스코프를 따른다.

함수를 어디서 호출했는가 아니라 함수를 어디서 정의했는지에 따라 상위 스코프를 결정한다.

함체 객체를 생성할 때 자신이 정의된 스코프를 상위 스크프로 기억한다.